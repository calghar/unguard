from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import TYPE_CHECKING

from ..core.k8s_client import K8sClient
from ..core.logger import SecurityLogger
from ..core.logger import setup_logger
from ..core.patch_utils import StandardVulnerablePatches
from ..core.patch_utils import StandardSecurityPatches
from ..core.command_builder import CommandResult, CommandStatus

if TYPE_CHECKING:
    from ..core.command_builder import Command, CommandSequence


@dataclass
class ExploitResult:
    """Result of an exploit attempt."""

    success: bool
    message: str
    evidence: list[str] | None = None
    impact: list[str] | None = None


class BaseExploit(ABC):
    """Base class for all security exploits."""

    # Common dangerous capabilities that pose security risks
    DANGEROUS_CAPABILITIES = ["SYS_ADMIN", "NET_ADMIN", "SYS_MODULE", "SYS_PTRACE", 
                              "DAC_OVERRIDE", "DAC_READ_SEARCH", "ALL"]

    name: str = ""
    risk_level: str = "MEDIUM"
    vulnerability_type: str = ""
    description: str = ""

    def __init__(
        self,
        k8s_client: K8sClient,
        service: str | None = None,
        logger: SecurityLogger | None = None,
    ):
        self.k8s = k8s_client
        self.service = service or self.get_default_service()
        self.logger = logger or SecurityLogger(setup_logger(__name__))

    @abstractmethod
    def get_default_service(self) -> str:
        """Get the default service for this exploit."""
        pass

    @abstractmethod
    def get_vulnerable_patch(self) -> list[dict]:
        """Get JSON patch to make service vulnerable."""
        pass

    @abstractmethod
    def get_secure_patch(self) -> list[dict]:
        """Get JSON patch to secure service."""
        pass

    @abstractmethod
    def check_vulnerability(self) -> bool:
        """Check if service is vulnerable."""
        pass

    @abstractmethod
    def demonstrate(self) -> ExploitResult:
        """Demonstrate the exploit."""
        pass

    def show_info(self) -> None:
        """Display exploit information."""
        print(f"""
                {"=" * 45}
                {self.name} Exploit
                {"=" * 45}
                Target: {self.service}
                Risk: {self.risk_level}

                {self.description}
                {"=" * 45}
            """)

    def make_vulnerable(self, dry_run: bool = False) -> bool:
        """Apply vulnerable configuration."""
        self.logger.info(
            f"Applying vulnerable configuration to {self.service}..."
        )
        patches = self.get_vulnerable_patch()

        if self.k8s.patch_deployment(self.service, patches, dry_run):
            if not dry_run:
                self.logger.success(
                    f"Applied vulnerable configuration to {self.service}"
                )
            return True
        return False

    def make_secure(self, dry_run: bool = False) -> bool:
        """Apply secure configuration."""
        self.logger.info(f"Applying secure configuration to {self.service}...")
        patches = self.get_secure_patch()

        # Pre-create security context if needed
        self._ensure_security_context()

        if self.k8s.patch_deployment(self.service, patches, dry_run):
            if not dry_run:
                self.logger.success(
                    f"Applied secure configuration to {self.service}"
                )
            return True
        return False

    def _ensure_security_context(self) -> None:
        """Ensure security context exists before patching."""
        deployment = self.k8s.get_deployment(self.service)
        if not deployment:
            return

        if (
            deployment.spec
            and deployment.spec.template
            and deployment.spec.template.spec
        ):
            containers = deployment.spec.template.spec.containers or []
            for i, container in enumerate(containers):
                if not container.security_context:
                    self.k8s.patch_deployment(
                        self.service,
                        [
                            {
                                "op": "add",
                                "path": f"/spec/template/spec/containers/{i}/securityContext",
                                "value": {},
                            }
                        ],
                    )

    def run_interactive(self) -> None:
        """Run interactive demonstration."""
        self.show_info()

        if not self.check_vulnerability():
            response = input(
                "Service is not vulnerable. Make it vulnerable? (y/n) "
            )
            if response.lower() == "y":
                self.make_vulnerable()
                print()
                import time

                time.sleep(2)

        result = self.demonstrate()

        if result.evidence:
            print("\nEvidence:")
            for evidence in result.evidence:
                print(f"  • {evidence}")

        if result.impact:
            print("\nImpact:")
            for impact in result.impact:
                print(f"  • {impact}")

    def build_security_context_patch(
        self, container_idx: int = 0
    ) -> list[dict]:
        """Build a base security context patch."""
        return [
            {
                "op": "add",
                "path": f"/spec/template/spec/containers/{container_idx}/securityContext",
                "value": {},
            }
        ]

    def build_privileged_patch(self, container_idx: int = 0) -> list[dict]:
        """Build patches for privileged mode."""
        patches = self.build_security_context_patch(container_idx)
        patches.extend(
            [
                {
                    "op": "add",
                    "path": f"/spec/template/spec/containers/{container_idx}/securityContext/privileged",
                    "value": True,
                },
                {
                    "op": "add",
                    "path": f"/spec/template/spec/containers/{container_idx}/securityContext/allowPrivilegeEscalation",
                    "value": True,
                },
            ]
        )
        return patches

    def build_secure_patch(self, container_idx: int = 0) -> list[dict]:
        """Build secure patches based on current deployment state."""
        deployment = self.k8s.get_deployment(self.service)
        if not deployment:
            return []

        return StandardSecurityPatches.basic_security(deployment, container_idx)

    def build_secure_patch_with_extra_fields(
        self,
        container_idx: int = 0,
        include_user_settings: bool = False,
        include_host_settings: bool = False,
    ) -> list[dict]:
        """Build secure patches with optional extra security fields."""
        deployment = self.k8s.get_deployment(self.service)
        if not deployment:
            return []

        if include_user_settings and include_host_settings:
            return StandardSecurityPatches.host_isolation(
                deployment, container_idx
            )
        elif include_user_settings:
            return StandardSecurityPatches.user_security(
                deployment, container_idx
            )
        else:
            return StandardSecurityPatches.basic_security(
                deployment, container_idx
            )

    def build_vulnerable_patch(
        self, vulnerability_type: str, container_idx: int = 0
    ) -> list[dict]:
        """Build vulnerable patches based on vulnerability type."""

        deployment = self.k8s.get_deployment(self.service)
        if not deployment:
            return []

        vulnerability_map = {
            "privileged_container": StandardVulnerablePatches.privileged_container,
            "dangerous_capabilities": StandardVulnerablePatches.dangerous_capabilities,
            "host_namespace_sharing": StandardVulnerablePatches.host_namespace_sharing,
            "missing_resource_limits": StandardVulnerablePatches.missing_resource_limits,
            "host_isolation_bypass": StandardVulnerablePatches.host_isolation_bypass,
        }

        patch_func = vulnerability_map.get(vulnerability_type)
        if patch_func:
            return patch_func(deployment, container_idx)
        else:
            raise ValueError(
                f"Unknown vulnerability type: {vulnerability_type}"
            )

    def execute_command_sequence(
        self, sequence: "CommandSequence"
    ) -> "ExploitResult":
        """Execute a command sequence and return structured results."""
        pod_name = self.k8s.find_pod_for_service(self.service)
        if not pod_name:
            return ExploitResult(
                success=False,
                message=f"Pod not found for service {self.service}",
            )

        # Build the combined command
        combined_command = sequence.build_combined_command()

        try:
            # Execute the command
            output = self.k8s.exec_in_pod(pod_name, str(combined_command))

            # Store output for potential printing
            self._last_command_output = output

            # Parse the result
            if hasattr(sequence, "_result_parser") and sequence._result_parser:
                result = sequence._result_parser(output)
            else:
                result = self._parse_command_result(output)

            return ExploitResult(
                success=True,
                message=f"{sequence.name} completed",
                evidence=result.evidence,
                impact=result.vulnerabilities,
            )

        except Exception as e:
            self.logger.error(f"Command execution failed: {e}")
            return ExploitResult(
                success=False,
                message=f"Command execution failed: {e}",
            )

    def _add_impact_summary(self, result: ExploitResult, summary_impact: list[str]) -> None:
        """Add impact summary to exploit result and display it."""
        if result.success:
            if hasattr(self, '_last_command_output'):
                print(self._last_command_output)

            self.logger.exploit("=== Impact Summary ===")
            for item in summary_impact:
                print(f"  • {item}")

            # Extend the result with summary impact
            if result.impact:
                result.impact.extend(summary_impact)
            else:
                result.impact = summary_impact

    def execute_single_command(self, command: "Command") -> "CommandResult":
        """Execute a single command and return parsed result."""
        pod_name = self.k8s.find_pod_for_service(self.service)
        if not pod_name:
            return CommandResult(
                output="Pod not found", status=CommandStatus.FAILED
            )

        try:
            output = self.k8s.exec_in_pod(pod_name, str(command))
            return self._parse_command_result(output)
        except Exception as e:
            self.logger.error(f"Command execution failed: {e}")
            return CommandResult(output=str(e), status=CommandStatus.FAILED)

    def _parse_command_result(self, output: str) -> "CommandResult":
        """Parse command output into structured result."""
        status = CommandStatus.SUCCESS
        evidence = []
        vulnerabilities = []

        # Pattern matching for security indicators
        if "❌ VULNERABLE:" in output or "❌ CRITICAL:" in output:
            status = CommandStatus.VULNERABLE
            for line in output.split("\n"):
                if "❌ VULNERABLE:" in line or "❌ CRITICAL:" in line:
                    vulnerabilities.append(line.strip())
        elif "✅ Protected:" in output:
            status = CommandStatus.PROTECTED

        # Extract evidence
        for line in output.split("\n"):
            if "[PROOF]" in line:
                evidence.append(line.strip())

        return CommandResult(
            output=output,
            status=status,
            evidence=evidence,
            vulnerabilities=vulnerabilities,
        )
