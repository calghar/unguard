"""Pythonic command builder system for container security testing."""

import re
import shlex
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any, Callable


class CommandStatus(Enum):
    """Command execution status."""
    SUCCESS = "success"
    FAILED = "failed"
    VULNERABLE = "vulnerable"
    PROTECTED = "protected"
    WARNING = "warning"


@dataclass
class CommandResult:
    """Structured result from command execution."""
    output: str
    status: CommandStatus
    evidence: List[str] = field(default_factory=list)
    vulnerabilities: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def add_evidence(self, evidence: str) -> 'CommandResult':
        """Add evidence to the result."""
        self.evidence.append(evidence)
        return self

    def add_vulnerability(self, vuln: str) -> 'CommandResult':
        """Add vulnerability to the result."""
        self.vulnerabilities.append(vuln)
        return self

    def is_vulnerable(self) -> bool:
        """Check if result indicates vulnerability."""
        return self.status == CommandStatus.VULNERABLE or len(self.vulnerabilities) > 0


class Command:
    """Represents a single shell command with validation and parsing."""

    def __init__(self, cmd: str, description: str = "", expected_status: int = 0):
        self.cmd = cmd.strip()
        self.description = description
        self.expected_status = expected_status
        self._validate()

    def _validate(self) -> None:
        """Validate command safety."""
        if not self.cmd:
            raise ValueError("Command cannot be empty")

        # Basic safety checks
        dangerous_patterns = [
            r'rm\s+-rf\s+/',  # Don't allow rm -rf /
            r':\(\)\{.*\}:',  # Fork bomb
            r'dd\s+if=/dev/zero\s+of=/dev/',  # Dangerous dd operations
        ]

        for pattern in dangerous_patterns:
            if re.search(pattern, self.cmd):
                raise ValueError(f"Potentially dangerous command pattern detected: {pattern}")

    def __str__(self) -> str:
        return self.cmd


class CommandBuilder:
    """Fluent interface for building shell commands."""

    def __init__(self):
        self.commands: List[str] = []
        self.description = ""

    def echo(self, message: str, prefix: str = "[*]") -> 'CommandBuilder':
        """Add an echo command."""
        escaped_msg = shlex.quote(f"{prefix} {message}")
        self.commands.append(f"echo {escaped_msg}")
        return self

    def info(self, message: str) -> 'CommandBuilder':
        """Add an info echo."""
        return self.echo(message, "[*]")

    def vulnerable(self, message: str) -> 'CommandBuilder':
        """Add a vulnerability indicator."""
        return self.echo(message, "❌ VULNERABLE:")

    def protected(self, message: str) -> 'CommandBuilder':
        """Add a protection indicator."""
        return self.echo(message, "✅ Protected:")

    def critical(self, message: str) -> 'CommandBuilder':
        """Add a critical finding."""
        return self.echo(message, "❌ CRITICAL:")

    def proof(self, message: str) -> 'CommandBuilder':
        """Add proof of concept output."""
        return self.echo(message, "[PROOF]")

    def newline(self) -> 'CommandBuilder':
        """Add a newline for spacing."""
        self.commands.append("echo")
        return self

    def if_file_exists(self, filepath: str) -> 'ConditionalBuilder':
        """Start a conditional block for file existence."""
        return ConditionalBuilder(self, f"[ -f {shlex.quote(filepath)} ]")

    def if_dir_exists(self, dirpath: str) -> 'ConditionalBuilder':
        """Start a conditional block for directory existence."""
        return ConditionalBuilder(self, f"[ -d {shlex.quote(dirpath)} ]")

    def if_command_exists(self, command: str) -> 'ConditionalBuilder':
        """Start a conditional block for command existence."""
        return ConditionalBuilder(self, f"command -v {shlex.quote(command)} >/dev/null 2>&1")

    def check_file_content(self, filepath: str, pattern: str, variable_name: str) -> 'CommandBuilder':
        """Check file content and store in variable."""
        safe_file = shlex.quote(filepath)
        safe_pattern = shlex.quote(pattern)
        self.commands.append(f'{variable_name}=$(cat {safe_file} 2>/dev/null | grep {safe_pattern} || echo "not_found")')
        return self

    def set_variable(self, name: str, value: str) -> 'CommandBuilder':
        """Set a shell variable."""
        safe_value = shlex.quote(value)
        self.commands.append(f"{name}={safe_value}")
        return self

    def run_command(self, cmd: str, capture_to: Optional[str] = None) -> 'CommandBuilder':
        """Run a raw command with optional output capture."""
        if capture_to:
            self.commands.append(f"{capture_to}=$({cmd})")
        else:
            self.commands.append(cmd)
        return self

    def build(self, description: str = "") -> Command:
        """Build the final command."""
        if description:
            self.description = description

        full_command = "\n".join(self.commands)
        return Command(full_command, self.description)


class ConditionalBuilder:
    """Builder for conditional command blocks."""

    def __init__(self, parent: CommandBuilder, condition: str):
        self.parent = parent
        self.condition = condition
        self.then_commands: List[str] = []
        self.else_commands: List[str] = []
        self.in_else = False

    def then(self) -> 'ConditionalBuilder':
        """Start the then block."""
        self.in_else = False
        return self

    def echo(self, message: str, prefix: str = "[*]") -> 'ConditionalBuilder':
        """Add an echo command to current block."""
        escaped_msg = shlex.quote(f"{prefix} {message}")
        cmd = f"echo {escaped_msg}"

        if self.in_else:
            self.else_commands.append(cmd)
        else:
            self.then_commands.append(cmd)
        return self

    def vulnerable(self, message: str) -> 'ConditionalBuilder':
        """Add vulnerability indicator."""
        return self.echo(message, "❌ VULNERABLE:")

    def protected(self, message: str) -> 'ConditionalBuilder':
        """Add protection indicator."""
        return self.echo(message, "✅ Protected:")

    def critical(self, message: str) -> 'ConditionalBuilder':
        """Add critical finding."""
        return self.echo(message, "❌ CRITICAL:")

    def proof(self, message: str) -> 'ConditionalBuilder':
        """Add proof of concept."""
        return self.echo(message, "[PROOF]")

    def run(self, cmd: str) -> 'ConditionalBuilder':
        """Add a raw command to current block."""
        if self.in_else:
            self.else_commands.append(cmd)
        else:
            self.then_commands.append(cmd)
        return self

    def run_command(self, cmd: str, capture_to: Optional[str] = None) -> 'ConditionalBuilder':
        """Run a raw command with optional output capture."""
        if capture_to:
            full_cmd = f"{capture_to}=$({cmd})"
        else:
            full_cmd = cmd

        if self.in_else:
            self.else_commands.append(full_cmd)
        else:
            self.then_commands.append(full_cmd)
        return self

    def else_(self) -> 'ConditionalBuilder':
        """Start the else block."""
        self.in_else = True
        return self

    def end_if(self) -> CommandBuilder:
        """End the conditional and return to parent builder."""
        # Build the if statement
        if_block = f"if {self.condition}; then"

        for cmd in self.then_commands:
            if_block += f"\n    {cmd}"

        if self.else_commands:
            if_block += "\nelse"
            for cmd in self.else_commands:
                if_block += f"\n    {cmd}"

        if_block += "\nfi"

        self.parent.commands.append(if_block)
        return self.parent


class SystemInfoCommands:
    """Pre-built system information gathering commands."""

    @staticmethod
    def current_user() -> Command:
        """Get current user information."""
        return (CommandBuilder()
                .info("Current user information:")
                .run_command("id")
                .build("Get current user"))

    @staticmethod
    def hostname() -> Command:
        """Get hostname."""
        return (CommandBuilder()
                .info("Hostname information:")
                .run_command("hostname")
                .build("Get hostname"))

    @staticmethod
    def process_count() -> Command:
        """Count visible processes."""
        return (CommandBuilder()
                .info("Checking process visibility...")
                .run_command("ps aux 2>/dev/null | wc -l", "proc_count")
                .run_command('echo "Total processes visible: $proc_count"')
                .if_command_exists("ps")
                .then()
                .run('[ "$proc_count" -gt 50 ]')
                .run('if [ $? -eq 0 ]; then')
                .vulnerable("Can see host processes!")
                .run('else')
                .protected("Limited process visibility")
                .run('fi')
                .else_()
                .echo("ps command not available", "[!]")
                .end_if()
                .build("Check process visibility"))

    @staticmethod
    def capabilities_check() -> Command:
        """Check process capabilities."""
        return (CommandBuilder()
                .info("Checking capabilities...")
                .if_file_exists("/proc/1/status")
                .then()
                .run('cap_eff=$(cat /proc/1/status | grep CapEff | awk \'{print $2}\')')
                .run('echo "Effective capabilities: $cap_eff"')
                .run('if [ "$cap_eff" = "000001ffffffffff" ]; then')
                .vulnerable("Has ALL capabilities!")
                .echo("This is the MAXIMUM capability set - complete privilege!", "  ")
                .run('elif [ "$cap_eff" != "0000000000000000" ]; then')
                .vulnerable("Has dangerous capabilities!")
                .run('else')
                .protected("No dangerous capabilities")
                .run('fi')
                .else_()
                .echo("Cannot check capabilities - /proc/1/status not accessible", "[!]")
                .end_if()
                .build("Check Linux capabilities"))


class SecurityTestCommands:
    """Pre-built security testing commands."""

    @staticmethod
    def privileged_check() -> Command:
        """Check if container is running in privileged mode."""
        return (CommandBuilder()
                .info("Checking if we are privileged...")
                .if_dir_exists("/sys")
                .then()
                .run('if [ -w /sys ]; then')
                .vulnerable("Can write to /sys - privileged container!")
                .run('if [ -d /sys/kernel/debug ]; then')
                .run('    if mount -t debugfs none /sys/kernel/debug 2>/dev/null; then')
                .run('        touch /sys/kernel/debug/test_write 2>/dev/null && {')
                .proof("Successfully created file in /sys/kernel/debug")
                .run('            rm -f /sys/kernel/debug/test_write')
                .run('        } || echo "[!] Debug filesystem mounted but cannot write"')
                .run('        umount /sys/kernel/debug 2>/dev/null')
                .run('    fi')
                .run('fi')
                .run('else')
                .protected("Cannot write to /sys")
                .run('fi')
                .else_()
                .echo("/sys directory not accessible", "[!]")
                .end_if()
                .build("Check privileged container status"))

    @staticmethod
    def host_filesystem_access() -> Command:
        """Check for host filesystem access."""
        return (CommandBuilder()
                .info("Attempting to access host filesystem...")
                .if_dir_exists("/proc/1/root/etc")
                .then()
                .critical("Can access host via /proc/1/root!")
                .run_command('host_hostname=$(cat /proc/1/root/etc/hostname 2>/dev/null || echo "access denied")')
                .proof("Host hostname: $host_hostname")
                .run('head -3 /proc/1/root/etc/passwd 2>/dev/null && echo "[PROOF] Can read host /etc/passwd"')
                .else_()
                .protected("Cannot access host filesystem via /proc/1/root")
                .end_if()
                .newline()
                .info("Checking device access...")
                .if_file_exists("/dev/mem")
                .then()
                .critical("Can access /dev/mem (physical memory)!")
                .end_if()
                .build("Check host filesystem access"))

    @staticmethod
    def network_capabilities() -> Command:
        """Test network manipulation capabilities."""
        return (CommandBuilder()
                .info("Testing NET_ADMIN capability...")
                .run('if ip link add dummy0 type dummy 2>/dev/null; then')
                .vulnerable("NET_ADMIN capability active!")
                .proof("Created network interface: dummy0")
                .run('ip link show dummy0 2>/dev/null | head -2')
                .run('ip link delete dummy0 2>/dev/null')
                .run('else')
                .protected("Cannot create network interfaces")
                .run('fi')
                .build("Test network capabilities"))

    @staticmethod
    def memory_limits_check() -> Command:
        """Check memory limits."""
        return (CommandBuilder()
                .info("Checking memory limits...")
                .if_file_exists("/sys/fs/cgroup/memory.max")
                .then()
                .run_command('limit=$(cat /sys/fs/cgroup/memory.max 2>/dev/null)')
                .run('[ "$limit" = "max" ]')
                .run('if [ $? -eq 0 ]; then')
                .vulnerable("No memory limit")
                .run('else')
                .protected("Memory limit: $limit")
                .run('fi')
                .else_()
                .if_file_exists("/sys/fs/cgroup/memory/memory.limit_in_bytes")
                .then()
                .run_command('limit=$(cat /sys/fs/cgroup/memory/memory.limit_in_bytes 2>/dev/null)')
                .run('[ "$limit" = "9223372036854771712" ]')  # Unlimited value
                .run('if [ $? -eq 0 ]; then')
                .vulnerable("No memory limit")
                .run('else')
                .protected("Memory limit: $limit")
                .run('fi')
                .else_()
                .echo("Cannot determine memory limits", "[!]")
                .end_if()
                .end_if()
                .build("Check memory limits"))


class ResourceTestCommands:
    """Commands for testing resource consumption."""

    @staticmethod
    def allocate_memory(size_mb: int, duration_sec: int = 5) -> Command:
        """Allocate memory for testing."""
        return (CommandBuilder()
                .info("Baseline memory:")
                .run_command('cat /proc/meminfo | grep -E "^MemFree|^MemAvailable" | awk \'{print "  " $1 " " int($2/1024) "MB"}\'')
                .newline()
                .info(f"Allocating {size_mb}MB...")
                .run_command(f'dd if=/dev/zero of=/dev/shm/test_mem bs=1M count={size_mb} 2>/dev/null')
                .newline()
                .info("Memory after allocation:")
                .run_command('cat /proc/meminfo | grep -E "^MemFree|^MemAvailable" | awk \'{print "  " $1 " " int($2/1024) "MB"}\'')
                .run_command(f'sleep {duration_sec}')
                .run_command('rm -f /dev/shm/test_mem')
                .protected(f"Successfully allocated and held {size_mb}MB without limits")
                .build(f"Allocate {size_mb}MB memory"))

    @staticmethod
    def cpu_burn_test(cores: int = 2, duration_sec: int = 3) -> Command:
        """CPU consumption test."""
        return (CommandBuilder()
                .info(f"Starting CPU load on {cores} cores...")
                .run_command('''
                    burn_cpu() {
                        local end=$(($(date +%s) + ''' + str(duration_sec) + '''))
                        local count=0
                        while [ $(date +%s) -lt $end ]; do
                            echo "scale=10; 4*a(1)" | bc -l > /dev/null 2>&1 || count=$((count+count+1))
                        done
                        echo "  Core $1: Completed"
                    }
                ''')
                .run_command(f'for i in $(seq 1 {cores}); do burn_cpu $i & done')
                .run_command('wait')
                .protected(f"Successfully consumed CPU on {cores} cores without limits")
                .build(f"CPU burn test on {cores} cores"))


class CommandSequence:
    """Manages a sequence of commands with result aggregation."""

    def __init__(self, name: str, description: str = ""):
        self.name = name
        self.description = description
        self.commands: List[Command] = []
        self.parsers: List[Callable[[str], CommandResult]] = []

    def add_command(self, command: Command, parser: Optional[Callable[[str], CommandResult]] = None) -> 'CommandSequence':
        """Add a command to the sequence."""
        self.commands.append(command)
        self.parsers.append(parser or self._default_parser)
        return self

    def add_system_info(self) -> 'CommandSequence':
        """Add basic system information commands."""
        self.add_command(SystemInfoCommands.current_user())
        self.add_command(SystemInfoCommands.hostname())
        self.add_command(SystemInfoCommands.capabilities_check())
        return self

    def add_privileged_test(self) -> 'CommandSequence':
        """Add privileged container tests."""
        self.add_command(SecurityTestCommands.privileged_check())
        self.add_command(SecurityTestCommands.host_filesystem_access())
        return self

    def add_network_test(self) -> 'CommandSequence':
        """Add network capability tests."""
        self.add_command(SecurityTestCommands.network_capabilities())
        return self

    def add_resource_test(self) -> 'CommandSequence':
        """Add resource limit tests."""
        self.add_command(SecurityTestCommands.memory_limits_check())
        self.add_command(ResourceTestCommands.allocate_memory(50, 5))
        return self

    def build_combined_command(self) -> Command:
        """Build all commands into a single executable command."""
        if not self.commands:
            raise ValueError("No commands added to sequence")

        combined_script = []
        for i, cmd in enumerate(self.commands):
            if i > 0:
                combined_script.append("")  # Add spacing between commands
            combined_script.append(f"# {cmd.description or f'Command {i+1}'}")
            combined_script.append(str(cmd))

        full_script = "\n".join(combined_script)
        return Command(full_script, f"{self.name}: {self.description}")

    def _default_parser(self, output: str) -> CommandResult:
        """Default result parser."""
        status = CommandStatus.SUCCESS
        evidence = []
        vulnerabilities = []

        # Simple pattern matching for common indicators
        if "❌ VULNERABLE:" in output or "❌ CRITICAL:" in output:
            status = CommandStatus.VULNERABLE
            # Extract vulnerability messages
            for line in output.split('\n'):
                if "❌ VULNERABLE:" in line or "❌ CRITICAL:" in line:
                    vulnerabilities.append(line.strip())
        elif "✅ Protected:" in output:
            status = CommandStatus.PROTECTED

        # Extract evidence (PROOF lines)
        for line in output.split('\n'):
            if "[PROOF]" in line:
                evidence.append(line.strip())

        return CommandResult(
            output=output,
            status=status,
            evidence=evidence,
            vulnerabilities=vulnerabilities
        )
