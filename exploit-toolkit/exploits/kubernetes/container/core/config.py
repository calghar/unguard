import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List

import yaml


@dataclass
class ExploitConfig:
    """Configuration for a single exploit."""

    name: str
    service: str
    risk_level: str
    description: str
    vulnerability_type: str


@dataclass
class Config:
    """Main configuration class."""

    namespace: str = os.getenv("K8S_NAMESPACE", "unguard")
    timeout: int = int(os.getenv("K8S_TIMEOUT", "300"))
    dry_run: bool = os.getenv("DRY_RUN", "false").lower() == "true"
    debug: bool = os.getenv("DEBUG", "false").lower() == "true"

    # Service names
    services: List[str] = field(
        default_factory=lambda: [
            "unguard-payment-service",
            "unguard-profile-service",
            "unguard-frontend",
            "unguard-membership-service",
            "unguard-user-auth-service",
            "unguard-ad-service",
            "unguard-proxy-service",
        ]
    )

    # Exploit mappings
    exploit_mappings: Dict[str, str] = field(
        default_factory=lambda: {
            "privileged-containers": "unguard-payment-service",
            "dangerous-capabilities": "unguard-profile-service",
            "host-namespace-sharing": "unguard-frontend",
            "missing-resource-limits": "unguard-membership-service",
        }
    )

    @classmethod
    def from_env(cls) -> "Config":
        """Create config from environment variables."""
        return cls(
            namespace=os.getenv("K8S_NAMESPACE", "unguard"),
            timeout=int(os.getenv("K8S_TIMEOUT", "300")),
            dry_run=os.getenv("DRY_RUN", "false").lower() == "true",
            debug=os.getenv("DEBUG", "false").lower() == "true",
        )

    @classmethod
    def from_file(cls, path: Path) -> "Config":
        """Load config from YAML file."""
        with open(path) as f:
            data = yaml.safe_load(f)

        # Validate YAML structure
        required_keys = ["namespace", "timeout", "services", "exploit_mappings"]
        for key in required_keys:
            if key not in data:
                raise ValueError(f"Missing required key in config: {key}")

        return cls(**data)
